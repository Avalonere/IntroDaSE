# 定义一个函数来计算整数拆分的最大乘积，并输出拆分结果
def integer_break_and_print(n):
    # 初始化一部字典来存储子问题的解
    dp = {1: 1, 2: 2}
    # 初始化一部字典来存储拆分的方案
    path = {1: [1], 2: [2]}
    # 从小到大遍历每个整数
    for i in range(3, n + 1):
        # 初始化当前整数的最大乘积为0
        max_product = 0
        # 初始化当前整数的拆分方案为空列表
        best_path = []
        # 遍历所有可能的拆分方案
        for j in range(1, i):
            # 计算当前拆分方案的乘积
            product = max(j * dp[i - j], j * (i - j))
            # 如果当前乘积大于之前的最大乘积，更新最大乘积和拆分方案
            if product > max_product:
                max_product = product
                # 如果j * dp[i - j]大于j * (i - j)，说明拆分了两次，需要合并两个列表
                if j * dp[i - j] > j * (i - j):
                    best_path = [j] + path[i - j]
                # 否则，只拆分了一次，直接添加两个元素到列表中
                else:
                    best_path = [j, i - j]
        # 把当前整数的最大乘积存入字典
        dp[i] = max_product
        # 把当前整数的拆分方案存入字典
        path[i] = best_path
    # 返回原问题的解和拆分方案
    return dp[n], path[n]


# 2001的分解结果应为667个3
# 这个问题的解决思路是使用动态规划的方法，把一个大问题分解成若干个小问题，然后用一个数组或者字典来存储子问题的解，最后根据子问题的解来得到原问题的解。
# 具体来说，我们可以把原问题看成是：给定一个正整数n，找出一种拆分方案，使得拆分出的正整数之和等于n，并且这些正整数的乘积最大。我们可以用一个函数f(n)来表示这个问题的解，即拆分出的正整数的最大乘积。 那么，我们如何求解f(
# n)呢？我们可以从小到大遍历每个整数，看看它们是如何拆分的。比如，对于n = 1和n = 2，我们可以发现它们没有办法再拆分了，所以它们的最大乘积就是它们本身，即f(1) = 1和f(2) = 2。 对于n >
# 2的情况，我们可以发现它们都可以拆分成两个正整数之和，比如n = i + (n - i)，其中i是从1到n - 1的任意整数。那么，我们可以比较所有可能的拆分方案，找出最大的乘积，即 f(n)=max(1≤i≤n−1){i×f(
# n−i),i×(n−i)} 这个公式的意思是，对于每个可能的拆分方案，我们都要考虑两种情况：一种是继续拆分(n - i)，另一种是不再拆分(n -
# i)。我们要取两者中较大的乘积作为当前方案的乘积。然后，在所有方案中取最大的乘积作为最终答案。 为了避免重复计算子问题的解，我们可以用一个数组或者字典来存储已经计算过的子问题的解。比如，我们可以用一个字典dp = {1: 1,
# 2: 2}来初始化，然后从小到大计算每个整数的最大乘积，并更新字典。
# 如果我们还想要输出拆分方案，那么我们还需要在代码中增加一些步骤来记录拆分的过程。我们可以用另一部字典来存储每个整数对应的拆分方案。比如，我们可以用一部字典path = {1: [1],
# 2: [2]}来初始化，然后在更新最大乘积的同时，也更新拆分方案。
